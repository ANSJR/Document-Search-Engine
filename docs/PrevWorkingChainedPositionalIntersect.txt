std::unordered_map<std::string, std::vector<size_t>> Searcher::chainedPositionalIntersect(const std::unordered_map<std::string, std::unordered_map<std::string, std::vector<size_t>>>& index,
    const std::vector<std::string>& queryTokens) {

    if (queryTokens.empty()) return {};

    auto token = index.find(queryTokens[0]);
    if (token == index.end()) return {};

    // Creates current with all files and their pos of first token of query from index
    std::unordered_map<std::string, std::vector<size_t>> currentToken = token->second;

    // For each next word, intersect positions doc-by-doc
    for (int i = 1; i < queryTokens.size(); i++) {
        // Creates nextToken with all files and their pos of next token of query from index
        auto nextToken = index.find(queryTokens[i]);

        if (nextToken == index.end()) {
            if (i + 1 != queryTokens.size()) return {};  // if next token not found return nothing ERROR FOR PREFIX

///////////////////bool prefixFound = tst.prefixSearch(nextToken); // returns a vector of strings with possible words 
        }


        std::unordered_map<std::string, std::vector<size_t>> resultingFileAndPositions;

        for (const auto& [file, positions1] : currentToken) {
            // If theres a matching file in nextToken to current
            auto found = nextToken->second.find(file);
            if (found != nextToken->second.end()) {
                // Gets Positional data of nextToken
                auto positions2 = found->second;
                // Finds intersection of Positional data of both current and nextToken
                auto newPositions = positionalIntersect(positions1, positions2);
                // If this file has matching Positional data for both
                if (!newPositions.empty()) {
                    // Hold data to use as next current token since this data had matched the prev current token and next token
                    resultingFileAndPositions[file] = newPositions;
                }
            }
        }
        // Will take replace prev current to check the next token in loop
        currentToken = std::move(resultingFileAndPositions);
    }

    return currentToken;  // Only docs where full sequence occurs survive
}