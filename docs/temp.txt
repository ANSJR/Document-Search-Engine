TreeNode* TernarySearchTree::findPrefixNode(TreeNode* node, const std::string& prefix, int index) const {
    if (!node) return nullptr;
    char c = prefix[index];

    if (c < node->data)
        return findPrefixNode(node->lChild, prefix, index);
    else if (c > node->data)
        return findPrefixNode(node->rChild, prefix, index);
    else {
        // Match
        if (index == prefix.size() - 1)
            return node;
        return findPrefixNode(node->mChild, prefix, index + 1);
    }
}

void TernarySearchTree::collectWords(TreeNode* node, std::string current, std::vector<std::string>& results) const {
    if (!node) return;

    // Left: alternative characters at this position
    collectWords(node->lChild, current, results);

    // Add current node's character
    current.push_back(node->data);

    // If this node is a complete word, save it
    if (node->marked)
        results.push_back(current);

    // Middle: next character in words
    collectWords(node->mChild, current, results);

    // Right: alternative characters at this position
    collectWords(node->rChild, current.substr(0, current.size() - 1), results);
}

std::vector<std::string> TernarySearchTree::prefixSearch(const std::string& prefix) const {
    std::vector<std::string> results;
    if (!root || prefix.empty()) return results;

    TreeNode* prefixNode = findPrefixNode(root, prefix, 0);
    if (!prefixNode) return results;

    // Start current as prefix minus the last character
    std::string current = prefix.substr(0, prefix.size() - 1);

    // Collect all words starting from the last node of the prefix
    collectWords(prefixNode, current, results);

    return results;
}

TreeNode* findPrefixNode(TreeNode* node, const std::string& prefix, int index) const;
    void collectWords(TreeNode* node, std::string current, std::vector<std::string>& results) const;
    std::vector<std::string> prefixSearch(const std::string& prefix) const;