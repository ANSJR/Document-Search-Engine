
#ifndef SEARCHER_H
#define SEARCHER_H

#include <string>
#include <vector>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <algorithm>
#include <cmath>
#include "Tokenizer.h"
#include "TernarySearchTree.h"
#include "Indexer.h"

/**
 * Handles all search operations over built index :
 * - Exact term search
 * - Prefix search via TST
 * - Multi-word and mixed (multi + prefix) queries
 * - TF-IDF ranking
 *
 * The Searcher uses the index generated by Indexer and a 
 * Ternary Search Tree for prefix expansions. Results are 
 * ranked by TF-IDF relevance scores and previous token position.
 */
class Searcher {
private:
    const std::unordered_map<std::string, std::unordered_map<std::string, std::vector<size_t>>>& index;
    const TernarySearchTree* tst;

    Tokenizer tokenizer;

    // will return a unsorted vector of this prefix partial token.
    std::vector<std::string> expandToken(const std::string& token) const;

    double computeTF(size_t termCountInDoc, size_t totalTermsInDoc) const;

    double computeIDF(size_t docsContainingTerm, size_t totalDocs) const;
    // added previousToken
    std::map<std::string, double> computeScores(std:: string& previousToken,
        const std::vector<std::string>& expandedTokens) const;
public:
    // default constructor
    Searcher(const std::unordered_map<std::string,
              std::unordered_map<std::string, std::vector<size_t>>>& idx,
             const TernarySearchTree* tst = nullptr);

    std::vector<std::pair<std::string, double>> search(const std::string& query);
};

#endif
