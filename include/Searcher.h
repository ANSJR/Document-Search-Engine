
#ifndef SEARCHER_H
#define SEARCHER_H


#include "Tokenizer.h"
#include "TernarySearchTree.h"
#include "Indexer.h"
#include <vector>
#include <unordered_map>
#include <map>

/**
 * Handles all search operations over built index :
 * - Exact term search
 * - Prefix search via TST
 * - Multi-word and mixed (multi + prefix) queries
 * - TF-IDF ranking
 *
 * The Searcher uses the index generated by Indexer and a 
 * Ternary Search Tree for prefix expansions. Results are 
 * ranked by TF-IDF relevance scores and previous token position.
 */
class Searcher {
private:
    const std::unordered_map<std::string, std::unordered_map<std::string, std::vector<size_t>>>& index;
    const TernarySearchTree* tst;
    Tokenizer tokenizer;

    std::vector<size_t> positionalIntersect(const std::vector<size_t>& pos1, const std::vector<size_t>& pos2);
    
    std::unordered_map<std::string, std::vector<size_t>> chainedPositionalIntersect(const std::unordered_map<std::string, std::unordered_map<std::string, std::vector<size_t>>>& index,
    const std::vector<std::string>& queryTokens);

    // will return a unsorted vector of this prefix partial token.
    std::vector<std::string> expandToken(const std::string& token) const;

    double computeTF(size_t termCountInDoc, size_t totalTermsInDoc) const;

    double computeIDF(size_t docsContainingTerm, size_t totalDocs) const;
    // added previousToken
    std::map<std::string, double> computeScores(
        const std::vector<std::string>& expandedTokens) const;
public:
    // default constructor
    Searcher(const std::unordered_map<std::string,
              std::unordered_map<std::string, std::vector<size_t>>>& idx,
             const TernarySearchTree* tst = nullptr);

    std::vector<std::pair<std::string, double>> search(const std::string& query);
};

#endif
